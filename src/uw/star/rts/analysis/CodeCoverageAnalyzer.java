package uw.star.rts.analysis;

import uw.star.rts.artifact.*;
import uw.star.rts.extraction.ArtifactFactory;

import java.nio.file.Path;
import java.util.*;

import org.slf4j.Logger;

import com.google.common.collect.ImmutableList;
/**
 * Coverage Analysis is used to identify the relationship between the test suite and the entities
 * in the system under test that are exercised by the test suite
 * A code coverage analyzer should be able to build a Coverage Matrix based on some artifacts created from test execution
 * 
 * @author Weining Liu
 *
 */
public abstract class CodeCoverageAnalyzer {
	
	ArtifactFactory af;
	Application testapp;
	Program program;
    TestSuite testSuite;
	Logger log;
	//containers for each entity types, these are populated by parseXML/parseHtml
	Set <SourceFileEntity> srcEntities;
	Set <ClassEntity> classEntities;
	Set <MethodEntity> methodEntities;
	Set <StatementEntity> stmEntities;

	//values of the following should be changed for each test case, i.e. class/method/statement coverage are different for each test case
	Set<SourceFileEntity> coveredSrcEntities;
	Set <ClassEntity> coveredClassEntities;
	Set <MethodEntity> coveredMethodEntities;
    Set <StatementEntity> coveredStmEntities;
    
    
    public CodeCoverageAnalyzer(ArtifactFactory af, Application testapp, Program p,TestSuite testSuite){
		this.af = af;
		this.testapp = testapp;
		this.program =p;
		this.testSuite= testSuite;

		srcEntities = new HashSet<>();
		classEntities = new HashSet<>();
		methodEntities = new HashSet<>();
		stmEntities = new HashSet<>();
		
		coveredSrcEntities= new HashSet<>();
		coveredClassEntities =new HashSet<>();
		coveredMethodEntities= new HashSet<>();
	    coveredStmEntities =new HashSet<>();
    }
	/**
	 * Let Ec denote the set of covered entities
	 * Ec = { e in E | (exist t in T)(t covers e)} 
	 * For every e in E, there must exist a t that executing t on P causes entity e 
	 * to be exercised at least once
	 *  
	 * @return
	 */ 
	public abstract <E extends Entity> CodeCoverage<E> createCodeCoverage(EntityType type);
	//parse code coverage reports generated by executing t on p
	public abstract void parseReport(Program p,TestCase t);

	/**
	 * Extract code entities of given type and link back to the program, src entities are set in any cases.
	 * It's ideal to use other ways to extract all entities(e.g source code parser) as Emma/Jacoco code coverage results do not contain interfaces.
	 * Ideally, the program artifact should contain ALL classes regardless it's interface or not. However, for the purpose
	 * of test case selection, since interface is never covered by any test cases, it makes no impact. 
	 * @param type
	 * @return
	 */

	public List<? extends Entity> extractEntities(EntityType type){
		List<? extends Entity> result = null;
		List<TestCase> testcases =testSuite.getTestCaseByVersion(program.getVersionNo());
		if(testcases.size()==0){
			log.error("test case set should not be zero");
		}else{
			TestCase t0 =testcases.get(0);
			log.debug("parse xml result of test case :" + t0);
			//parse any xml result file would have the same entities
			clearAll();
			parseReport(program,t0);
			switch(type){
			case CLAZZ : 
				result= ImmutableList.copyOf(classEntities);
			break;
			
			case METHOD : 
				result= ImmutableList.copyOf(methodEntities);
			break;
			
			case SOURCE : 
				result =  ImmutableList.copyOf(srcEntities);
			break;
			
			case STATEMENT: 
				result = ImmutableList.copyOf(stmEntities);
			break;
			
			default : 
				log.error("unknown enum value found" + type);
			}
			
			//always link source entities to program as all other types are linked to source
			if(!type.equals(EntityType.SOURCE)) 
				program.setCodeEntities(EntityType.SOURCE, ImmutableList.copyOf(srcEntities));
			program.setCodeEntities(type,result);
		}
		return result;
	}
	
	
	/**
	 * extract covered code entities of given type 
	 * @param type
	 * @param tc - code entities covered by this test case 
	 * @return
	 */
	public  List<? extends Entity> extractCoveredEntities(EntityType type,TestCase tc){
       clearAll();//this is done to clear coveredEntities sets before each parsing. CoveredEntities are different when a different jacocoXMLReport is given
	    
		List<? extends Entity> result = null;
			log.debug("parse xml result of test case :" + tc);
			parseReport(program,tc);
			switch(type){
			case CLAZZ : 
				result= ImmutableList.copyOf(coveredClassEntities);
				break;

			case METHOD : 
				result= ImmutableList.copyOf(coveredMethodEntities);
				break;

			case SOURCE : 
				result =  ImmutableList.copyOf(coveredSrcEntities);
				break;

			case STATEMENT: 
				result = ImmutableList.copyOf(coveredStmEntities);
				break;

			default : 
				log.error("unknown enum value found" + type);
			}
		return result;
	}
	
	
	/**
	 * Construct a trace matrix by going through all coverage result files of all test cases.
	 * 
	 * A trace matrix of a particular type (class/method) is constructed by 
	 *   1) extract all test cases of the version(same version as p) as the row of the matrix 
	 *   2) extract all class/method entities of the version as the column
	 *   3) for each coverage file, extract Covered Entities
	 *   4) insert covered entities into the Trace matrix 
	 * @param app
	 * @return a trace between entities of specified type and all test cases in the test suite
	 */
	public <E extends Entity> CodeCoverage<E> createCodeCoverage(EntityType type, TraceType traceType){
		//1)rows index
		List<TestCase> testcases = testSuite.getTestCaseByVersion(program.getVersionNo());
		//2)columns index
		List<E> entities = new ArrayList<>();
		for(Entity e:this.extractEntities(type)) 
		                     entities.add((E)e);
		
		Path codeCoverageResultFolder = null;
		CodeCoverage<E> coverage = new CodeCoverage<E>(traceType,testcases,entities,codeCoverageResultFolder);
		//3
		for(TestCase tc: testcases){ //set link for every test case
			Path coverageResultFile =af.getCoverageResultFile(traceType,program,tc,"xml");
			if(codeCoverageResultFolder==null) codeCoverageResultFolder=coverageResultFile.getParent();
			List<E> coveredEntites = new ArrayList<>();
			for(Entity e:this.extractCoveredEntities(type,tc) )
				coveredEntites.add((E)e);
			//4
			coverage.setLink(tc,coveredEntites);
		}
		coverage.setArtifactFile(codeCoverageResultFolder);
		return coverage;
	}
    
	/**
	 * Parse test case name from the result file name
	 * coverage.testcasename.xml
	 * @return
	 */
	String extractTestCaseName(Path xmlfile){
		//log.debug("file name is :"+ xmlfile.getFileName().toString());
		String filename = xmlfile.getFileName().toString();
		String tcName = filename.substring(filename.indexOf(".")+1,filename.lastIndexOf("."));
		//log.debug("test case name is: "+ tcName);
		return tcName;
	}

	void clearAll(){
		srcEntities.clear();
		classEntities.clear();
		methodEntities.clear();
		stmEntities.clear();
		
		coveredSrcEntities.clear();
		coveredClassEntities.clear();
		coveredMethodEntities.clear();
	    coveredStmEntities.clear();
	}
}
